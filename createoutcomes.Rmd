---
title: "DoD Military Community and Family Policy Military OneSource eNewsletter"
author: "Paul Testa and Jake Bowers"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
    html_document:
        toc: TRUE
	template: cosmo
---

```{r init,echo=F}
library(knitr)
opts_chunk$set(eval=T,echo=F,results="hide",message=F,warning=F,cache=T)

```

\tableofcontents

# Setup

- Download "designdata.csv" and "subscriptiondata.csv" onto local machine
- Load files and libaries

```{r setup}
wrkdat<-read.csv("data/designdata.csv",as.is=TRUE)
subscribers<-read.csv("data/subscriptiondata.csv",as.is=TRUE)

```


# Data

First check data

```{r clean}
stopifnot(nrow(wrkdat)==491879) # 491879 observations

# Make sure emails are unique:
stopifnot(length(unique(wrkdat$emailhash))==dim(data)[1])
stopifnot(length(unique(subscribers$emailhash))==dim(subscribers)[1])

stopifnot(nrow(subscribers)==7759) # 7759 subscriptions
stopifnot(sum(wrkdat$emailhash%in%subscribers$emailhash)==5563) # 5563 subscribers in initial email list

# Rename Treatment indicator
names(wrkdat)[3]<-"treatment"
```

Some people share names. And this will come to be a problem for the analysis of
this data. We engage with it below. In this section, we mostly explore the
extent to which people share names.

```{r}
# Create indicator for multiple names
# Data
multi_names<-names(which(table(wrkdat$name1hash)>1))
wrkdat$multi_name01<-ifelse(wrkdat$name1hash%in%multi_names,1,0)
table(wrkdat$multi_name01) # 152828 rows share names with at least one other person

# Subscribers
multi_names_sub<-names(which(table(subscribers$name1hash)>1))
subscribers$multi_name01<-ifelse(subscribers$name1hash%in%multi_names_sub,1,0)
stopifnot(table(subscribers$multi_name01)[2]==142) # 142 rows share names with at least one other person
table(table(subscribers$name1hash))

# Distribution of multiple names: Data
no_of_multi<-sort(unique(table(wrkdat$name1hash)))
counts<-hist(table(wrkdat$name1hash),plot=F,breaks=0:93)$count
counts<-counts[counts!=0]
tab_names_data<-cbind(c(no_of_multi,"No Name"),
                          c(counts,sum(is.na(wrkdat$name1hash))),
                          c(counts,sum(is.na(wrkdat$name1hash)))*c(no_of_multi,1)
                          )
colnames(tab_names_data)<-c("Times Name Appears","Frequency","Observations")
# Distribution of multiple names: Subscribers
no_of_multi_sub<-sort(unique(table(subscribers$name1hash)))
counts_sub<-hist(table(subscribers$name1hash),breaks=0:4,plot=F)$count
counts_sub<-counts_sub[counts_sub!=0]
tab_names_sub<-cbind(c(no_of_multi_sub,"No Name"),
                          c(counts_sub,sum(is.na(subscribers$name1hash))),
                          c(counts_sub,sum(is.na(subscribers$emailhash)))*c(no_of_multi_sub,1)
                          )
colnames(tab_names_sub)<-c("Times Name Appears","Frequency","Observations")
```

First, we match those sent email treatments to subscribers by email address. 

```{r}
# Matches by email
stopifnot(sum(wrkdat$emailhash%in%subscribers$emailhash)==5563) # 5563

# Matches by name1hash
stopifnot(sum(wrkdat$name1hash%in%subscribers$name1hash)==7951) # 7951 subscribers in

# Additional variables
summary(wrkdat$Order.Within.Condition)
table(wrkdat$Condition.Order.Within.Batch)

### Make sure that each row is a unique email address
stopifnot(nrow(wrkdat)==length(unique(wrkdat$emailhash)))
stopifnot(nrow(subscribers)==length(unique(subscribers$emailhash)))
row.names(wrkdat)<-wrkdat$emailhash
row.names(subscribers)<-subscribers$emailhash

## Make sure that Subscribe.Date has no missing values or extreme values.
stopifnot(all(!is.na(subscribers$Subscribe.Date)))
sort(unique(subscribers$Subscribe.Date))[1:10]
rev(sort(unique(subscribers$Subscribe.Date)))[1:10]
```


First match on email addresses. If an email address in the design data ends up
in the subscriber file, then we know that person subscribed to the newsletter.

```{r}
bigdat<-wrkdat
matchedemails<-intersect(row.names(bigdat),row.names(subscribers))
bigdat[matchedemails,"sdate"]<-subscribers[matchedemails,"Subscribe.Date"]
stopifnot(sum(!is.na(bigdat$sdat))==5563)

subscribers$noemailmatch<- !(row.names(subscribers) %in% matchedemails)
stopifnot(sum(!subscribers$noemailmatch)==5563)

subdat<-subscribers[subscribers$noemailmatch,]

stopifnot(nrow(subdat)==2196)
```


Next, among those 2169 unmatched subscribers, try to match on name within
batch. This is tricky but we start simple.  Add batch information to the
subscription file to add in merging otherwise we will have *at least* 900
subscriptions with no match to the experimental treatments.

We assume that if you have subscribed after the mailing of batch A but before
batch B, then you were randomized to batch A.

```{r}
table(designdata$Batch)
table(as.Date(subscriptiondata$Subscribe.Date,format="%m/%d/%y"),exclude=c())
``

Add start date of batch using information provided by the agency.^[After cleaning the file in a spreadsheet to remove extraneous information.]

```{r}
batchdates<-read.csv("batchdates.csv",as.is=TRUE,header=TRUE,strip.white=TRUE)
## Remove empty rows
batchdates[batchdates==""]<-NA ## replace empty strings with NA
emptyrow<-apply(batchdates,1,function(x){ all(is.na(x))})
badrows<-apply(batchdates,1,function(x){ tmp<-grep("TAR",x); if(length(tmp)==0){ return(FALSE) } else { TRUE } })
batchdates<-batchdates[!emptyrow & !badrows,]
batchdates$Batch<-rep(1:82,each=2)
stopifnot(all(na.omit(batchdates$Batch.Number-batchdates$Batch)==0))

## Fill in treatment information
batchdates$eMail.to.send[seq(2,164,by=2)]<-batchdates$eMail.to.send[seq(1,163,by=2)]
batchdates$eMail.to.send.1[seq(2,164,by=2)]<-batchdates$eMail.to.send.1[seq(1,163,by=2)]
batchdates$eMail.to.send.2[seq(2,164,by=2)]<-batchdates$eMail.to.send.2[seq(1,163,by=2)]
batchdates$eMail.to.send.3[seq(2,164,by=2)]<-batchdates$eMail.to.send.3[seq(1,163,by=2)]
batchdates$eMail.to.send.4[seq(2,164,by=2)]<-batchdates$eMail.to.send.4[seq(1,163,by=2)]
batchdates$eMail.to.send.5[seq(2,164,by=2)]<-batchdates$eMail.to.send.5[seq(1,163,by=2)]

## Pull off the actual send times

bdlong<-reshape(batchdates,direction="long",v.names=c("eMail.to.send","Details"),
		varying=list(eMail.to.send=grep("eMail.to.send",names(batchdates),value=TRUE),
			     Details=grep("Details",names(batchdates),value=TRUE)))


bdlongActual <- bdlong[grep("Actual",bdlong$Details),]

## Three actual send times were not recorded (we assume they were actually sent). So use the set time.
##bdlongActual[bdlongActual$Batch==16&bdlongActual$eMail.to.send=="A",] <- bdlong[bdlong$Batch==16&bdlong$eMail.to.send=="A"&bdlong$Batch.Number==16,"Details"]
## Strip off "PM"
bdlongActual[bdlongActual$Batch==16&bdlongActual$eMail.to.send=="A","Details"] <- bdlong["31.4","Details"]
bdlongActual[bdlongActual$Batch==36&bdlongActual$eMail.to.send=="E","Details"] <- bdlong["71.5","Details"]
bdlongActual[bdlongActual$Batch==80&bdlongActual$eMail.to.send=="F","Details"] <- bdlong["159.6","Details"]

## Make sure that each treatment is associated with one and only one batch
stopifnot(all(with(bdlongActual,table(Batch,eMail.to.send))==1))

## Convert Details into dates
bdlongActual$dateString<-sapply(strsplit(bdlongActual$Details,":\ "),function(x){ x[2] })
bdlongActual$date <- as.Date(bdlongActual$dateString,format="%d-%b-%Y %H:%M:%S")
bdlongActual[grep("PM",bdlongActual$dateString),"date"]<-as.Date(bdlongActual$dateString[grep("PM",bdlongActual$dateString)],
								 ,format="%m/%d/%Y %H:%M:%S %p")
stopifnot(sum(is.na(bdlongActual$date))==0)
table(bdlongActual$date)
```

Now, the subscription data only has day of subscription, no time. So, in order
to map date of subscription onto batch among those not matched by email, we
have to collapse batches into a day (often there were two batches per day). We
hope that we can still back out original batch after doing the matching by name
and collapsed-batch.

```{r}
subdat$dateDay<-as.Date(subdat$Subscribe.Date,format="%m/%d/%y")

## Batch Day/Collapsed Batch to Date mapping
bdlongActual$dateDay <- round(bdlongActual$date)
stopifnot(length(unique(bdlongActual$dateDay))==41)

batchdaydat<-data.frame(dateDay=unique(bdlongActual$dateDay),
			batchday=rank(unique(bdlongActual$dateDay)))
row.names(batchdaydat)<-batchdaydat$dateDay

subdat2<-merge(subdat,batchdaydat,all.x=TRUE,sort=FALSE)
## Now we have some subscription dates that are not on a mailing day
sum(is.na(subdat2$batchday))

intermaildates<-unique(subdat2$dateDay[is.na(subdat2$batchday)])
## Choose the mailing date that is closest to the subscription day, yet before the subscription day

getcloseday<-function(x){
	# x is date subscribed, a scalar
	y <- batchdaydat$dateDay
	thediff<-x - y
	return( as.Date(max(y[thediff>=0])) )
}

getcloseday(subdat2$dateDay[1])

## This is a very weird hack to ensure that the newdate column stayed a Date
newdate <- vector(length=nrow(subdat2))
class(newdate)<-"Date"
for(i in 1:length(subdat2$dateDay)){
	newdate[i]<-getcloseday(subdat2$dateDay[i])
}
subdat2$newdate<-newdate

stopifnot(all(with(subdat2[!is.na(subdat2$batchday),],dateDay-newdate)==0))

subdat2$batchday2<-NA
subdat2$batchday2 <- batchdaydat[as.character(subdat2$newdate),"batchday"]

## Check that each newdate is associated with one batch
thetab<-with(subdat2,table(newdate,batchday2))
stopifnot(all(c(unique(thetab[upper.tri(thetab)]), unique(thetab[lower.tri(thetab)]))==0))

```

Now, make a collapsed batchday variable on the design data:

```{r}
wrkdat$batchday<-as.numeric(cut(wrkdat$Batch,seq(0,82,by=2)))

tmptab<-with(wrkdat,table(batchday,Batch))
stopifnot(all(apply(tmptab,1,function(x){ sum(x!=0) }) == 2 ))
stopifnot(all(apply(tmptab,2,function(x){ sum(x!=0) }) == 1 ))

stop
break
```



First, only match unique names (i.e. unique names on the design data).
There are 881 unique names in the design data that have matches among subscribers
without matching email addresses.  Among those names, 880 are unique in the
subscribers database.

Here we see that, among subjects with no email matches, we have some very common names, for example 1 name is repeated 53 times.
```{r}
## Here we see that, among subjects with no email matches, we have some very common names, for example 1 name is repeated 53 times.
table( table(bigdat$name1hash[is.na(bigdat$sdate) & (bigdat$name1hash %in% subdat$name1hash)]) )
tmptabD<-table(bigdat$name1hash[is.na(bigdat$sdate) & (bigdat$name1hash %in% subdat$name1hash)])
tmptabS<-table(subdat$name1hash[subdat$name1hash %in% names(tmptabD[tmptabD==1])])
```

Now, this second round of matching is difficult to validate: we don't really
know if a "Jake Bowers" in both datasets is the same person. We only know that
"Jake Bowers" only appeared once in each dataset and that the email addresses
of Jake Bowers do not match between the two. For this next step, we are willing
to risk a bit of bias here: we imagine that names that only occur once in each
file are very likely to be the same person.

```{r}
bigdat2<-merge(bigdat,
	       subdat[subdat$name1hash %in% names(tmptabS[tmptabS==1]),]
	       ,by="name1hash",all.x=TRUE,sort=FALSE,suffixes=c(".big",".sub"))

with(bigdat2,table(is.na(sdate),is.na(Subscribe.Date)))
bigdat2$sdate2 <- ifelse(is.na(bigdat2$sdate),bigdat2$Subscribe.Date,bigdat2$sdate)

```

Now, we have about 1316 people in the subscribers file who did not match on
email and who could, in theory, be matched with more than one design data row.

On one hand, we have about 20 people with the same names in the unmatched part
of the subscribers file.

```{r}

subdat2 <- subdat[!(subdat$name1hash %in% names(tmptabS[tmptabS==1])),]
table(table(subdat2$name1hash))
sum(table(subdat2$name1hash)[table(subdat2$name1hash)>1])

```

On the design data, we have up to 9 names remaining to match. And many of these
are not unique (for example, see the following table for the first name listed
in this group).

```{r}
designnames2<-bigdat2[is.na(bigdat2$sdate2),grep("^name",names(bigdat2))]
apply(designnames2,2,function(x){ sum(!is.na(x)) })
table(table(designnames2$name1hash))
numnames<-rowSums(!is.na(designnames2))
table(numnames)
```

First, we exclude subscribers for which we have no match on name at all. This
leaves us with 451 unique names out of the remaining `r nrow(subdat2)` names.

```{r}
alldesignnames2<-unlist(designnames2)
possmatchnames<- intersect(subdat2$name1hash,alldesignnames2)
length(possmatchnames)
table(table(subdat2$name1hash[subdat2$name1hash %in% possmatchnames]))
```

There are 8 unique matches in the long list of designnames.

```{r}

tmptabS2<-table(alldesignnames2[alldesignnames2 %in% possmatchnames])

tmptabS3<-table(subdat2$name1hash[subdat2$name1hash %in% names(tmptabS2[tmptabS2==1])])

uniqueothermatches<-names(tmptabS3[tmptabS3==1])
length(uniqueothermatches)
```

So, we can add those to the design file.

The rest of the subscribers data is either (1) unmatchable (i.e. no matching
email address, no matching names) or (2) does not have unique name matches such
that we could not, with confidence, attribute a subscription to a given
treatment.




